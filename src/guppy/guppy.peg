{
package main

type ValueType int

const (
    STRING = iota
    INT
    FLOAT
    BOOL
    CHAR
    CONTAINER
    NIL
)

type BasicAst struct {
    Type string
    StringValue string
    CharValue rune
    BoolValue bool
    IntValue int
    FloatValue float64
    ValueType ValueType
    Subvalues []Ast
}

type Func struct {
    Arguments []Ast
    ValueType ValueType
    Subvalues []Ast
}

type Ast interface {
    Print(indent int) string
}

func main(){
    input := `
let a = -4 + 55.0 > 99 or "hi" ++ 'm';
let b = "cheese" ++ "ham";
let c = 5.0;
34 + 5;
let go = fun num -> {
    num + 5;
}
let cheesy = fun item -> {
    item ++ " with cheese";
}
`
    fmt.Println(input)
    r := strings.NewReader(input)
    result, err := ParseReader("", r)
    ast := result.(BasicAst)
    fmt.Println("=", ast.Print(0))
    fmt.Println(err)
}

func (a BasicAst) String() string {
    switch (a.ValueType){
        case STRING:
            return fmt.Sprintf("\"%s\"", a.StringValue)
        case CHAR:
            return fmt.Sprintf("'%s'", string(a.CharValue))
        case INT:
            return fmt.Sprintf("%d", a.IntValue)
        case FLOAT:
            return fmt.Sprintf("%f", a.FloatValue)
    }
    return "()"
}

func (a BasicAst) Print(indent int) string {
    str := ""

    for i := 0; i < indent; i++ {
        str += "  "
    }
    str += fmt.Sprintf("%s %s:\n", a.Type, a)
    for _, el := range(a.Subvalues){
        str += el.Print(indent+1)
    }
    return str
}

func (a Func) String() string {
    return "fun"
}

func (a Func) Print(indent int) string {
    str := ""

    for i := 0; i < indent; i++ {
        str += "  "
    }
    str += "fun"
    if len(a.Arguments) > 0 {
        str += " ("
        for _, el := range(a.Arguments){
            str += el.Print(indent)
        }
        str += ") "
    }
    for _, el := range(a.Subvalues){
        str += el.Print(indent+1)
    }
    return str
}

func toIfaceSlice(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}

}

Module = _ expr:Statement _ rest:(Statement)* _ EOF {
    vals := rest.([]interface{})
    if len(vals) > 0 {
        subvalues := []Ast{expr.(BasicAst)}
        for _, el := range(vals){
            subvalues = append(subvalues, el.(BasicAst))
        }
        return BasicAst{Type: "Module", Subvalues: subvalues, ValueType:CONTAINER }, nil
    } else {
        return BasicAst{Type: "Module", Subvalues: []Ast{expr.(BasicAst)}, ValueType:CONTAINER }, nil
    }
}

Statement = "let" __ i:Identifier _ '=' _ expr:Expr _ {
    fmt.Printf("assignment: %s\n", string(c.text))
    return BasicAst{Type: "Assignment", Subvalues: []Ast{i.(BasicAst),expr.(BasicAst)}, ValueType:CONTAINER }, nil
} / Expr

Expr = FuncDefn / BinExpr

FuncDefn = "fun" __ ids:(Identifier __)* _ "->" _ '{' _ statements:(Statement)+ _ '}' _ {
    fmt.Println("func", string(c.text))
    subvalues := []Ast{}
    args := []Ast{}
    vals := statements.([]interface{})
    if len(vals) > 0 {
        for _, el := range(vals){
            subvalues = append(subvalues, el.(BasicAst))
        }
    }
    vals = ids.([]interface{})
    if len(vals) > 0 {
        restSl := toIfaceSlice(ids)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[0].(BasicAst)
            args = append(args, v)
        }
    }
    return Func{Arguments: args, Subvalues: subvalues, ValueType:CONTAINER }, nil
}

BinExpr = _ op:BinOp rest:(BinOp)* _ ';' _ {
    vals := rest.([]interface{})
    if len(vals) > 0 {
        subvalues := []Ast{op.(BasicAst)}
        for _, el := range(vals){
            subvalues = append(subvalues, el.(BasicAst))
        }
        return BasicAst{Type: "Expr", Subvalues: subvalues, ValueType:CONTAINER }, nil
    } else {
        return BasicAst{Type: "Expr", Subvalues: []Ast{op.(BasicAst)}, ValueType:CONTAINER }, nil
    }
}

BinOp = BinOpBool / BinOpEquality / BinOpLow / BinOpHigh

BinOpBool = _ first:BinOpEquality rest:(__ OperatorBoolean __ BinOpEquality)* {
    vals := rest.([]interface{})
    if len(vals) > 0 {
        subvalues := []Ast{first.(BasicAst)}
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[3].(BasicAst)
            op := restExpr[1].(BasicAst)
            subvalues = append(subvalues, op, v)
        }
        return BasicAst{Type: "BinOp", Subvalues: subvalues, ValueType:CONTAINER }, nil
    } else {
        return first.(BasicAst), nil
    }
}

BinOpEquality = _ first:BinOpLow rest:(__ OperatorEquality __ BinOpLow)* {
    vals := rest.([]interface{})
    if len(vals) > 0 {
        subvalues := []Ast{first.(BasicAst)}
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[3].(BasicAst)
            op := restExpr[1].(BasicAst)
            subvalues = append(subvalues, op, v)
        }
        return BasicAst{Type: "BinOp", Subvalues: subvalues, ValueType:CONTAINER }, nil
    } else {
        return first.(BasicAst), nil
    }

}

BinOpLow = _ first:BinOpHigh rest:(__ OperatorLow __ BinOpHigh)* {
    vals := rest.([]interface{})
    if len(vals) > 0 {
        subvalues := []Ast{first.(BasicAst)}
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[3].(BasicAst)
            op := restExpr[1].(BasicAst)
            subvalues = append(subvalues, op, v)
        }
        return BasicAst{Type: "BinOp", Subvalues: subvalues, ValueType:CONTAINER }, nil
    } else {
        return first.(BasicAst), nil
    }

}

BinOpHigh = _ first:Value rest:(__ OperatorHigh __ Value)* {
    vals := rest.([]interface{})
    if len(vals) > 0 {
        subvalues := []Ast{first.(BasicAst)}
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[3].(BasicAst)
            op := restExpr[1].(BasicAst)
            subvalues = append(subvalues, op, v)
        }
        return BasicAst{Type: "BinOp", Subvalues: subvalues, ValueType:CONTAINER }, nil
    } else {
        return first.(BasicAst), nil
    }
}

Operator = OperatorBoolean / OperatorEquality / OperatorHigh / OperatorLow

OperatorBoolean = ( "not" / "or" / "and" ) {
    return BasicAst{Type:"BoolOp", StringValue:string(c.text), ValueType:STRING}, nil
}

OperatorEquality = ( ">=" / "<=" / '<' / '>' / "===" / "=="){
    return BasicAst{Type:"EqualityOperator", StringValue:string(c.text), ValueType:STRING}, nil
}

OperatorHigh = ( "/." / "*." ) {
    return BasicAst{Type:"FloatOperator", StringValue:string(c.text), ValueType:STRING}, nil
}
/ ( '*' / '/' / '^' ) {
    return BasicAst{Type:"IntOperator", StringValue:string(c.text), ValueType:STRING}, nil
}
/ "++" {
    return BasicAst{Type:"StringOperator", StringValue:string(c.text), ValueType:STRING}, nil
}

OperatorLow = ( "+." / "-." ) {
    return BasicAst{Type:"FloatOperator", StringValue:string(c.text), ValueType:STRING}, nil
}
/ ( '+' / '-' ) {
    return BasicAst{Type:"IntOperator", StringValue:string(c.text), ValueType:STRING}, nil
}

Value = Identifier / v:Const {
    return v.(BasicAst), nil
}
/ '(' expr:Expr ')' {
    return expr.(BasicAst), nil
}

Identifier = ([a-z]+ [a-zA-Z0-9_]* / '_') {
    return  BasicAst{Type:"Identifier", StringValue:string(c.text), ValueType:STRING}, nil
}

Const = '-'? [0-9]+ !'.' {
    val, err := strconv.Atoi(string(c.text))
    if err != nil {
        return nil, err
    }
    return  BasicAst{Type:"Integer", IntValue:val, ValueType:INT}, nil
}
/ '-'? [0-9]+ '.' [0-9]+ {
    val, err := strconv.ParseFloat(string(c.text),64)
    if err != nil {
        return nil, err
    }
    return  BasicAst{Type:"Float", FloatValue:val, ValueType:FLOAT}, nil
}
/ "True" / "False" {
    if string(c.text) == "True" {
        return BasicAst{Type:"Bool", BoolValue: true, ValueType:BOOL}, nil
    }
    return BasicAst{Type:"Bool", BoolValue: false, ValueType:BOOL}, nil
}
/ "()" {
    return BasicAst{Type:"Nil", ValueType:NIL}, nil
}
/ '"' (!EscapedChar .)* '"' {
    val, err := strconv.Unquote(string(c.text))
    if err == nil {
        return BasicAst{Type:"String", StringValue: val, ValueType:STRING}, nil
    }
    return nil, err
}
/ "'" val:(!EscapedChar .) "'" {
    return BasicAst{Type:"Char", CharValue: rune(c.text[1]), ValueType:CHAR}, nil
}

EscapedChar = [\x00-\x1f"\\]

EscapeSequence = SingleCharEscape / UnicodeEscape

SingleCharEscape = ["\\/bfnrt]

DecimalDigit = [0-9]

NonZeroDecimalDigit = [1-9]

HexDigit = [0-9a-f]i

__ "sigwhitespace" = [ \r\n\t]+

_ "whitespace" = [ \r\n\t]*

EOF = !.