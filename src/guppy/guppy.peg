{
package main

type ValueType int

const (
    STRING = iota
    INT
    FLOAT
    BOOL
    CHAR
    CONTAINER
)

type Ast struct {
    Type string
    StringValue string
    CharValue rune
    BoolValue bool
    IntValue int
    FloatValue float64
    ValueType ValueType
    Subvalues []Ast
}

type Printable interface {
    Print(indent int) string
}

type PrintableValue interface {
    PrintValue() string
}

func (a *Ast) PrintValue() string {
    switch (a.ValueType){
        case STRING:
            return a.StringValue
        case INT:
            return fmt.Sprintf("%d", a.IntValue)
        case FLOAT:
            return fmt.Sprintf("%f", a.FloatValue)
    }
    return "()"
}

func (a *Ast) Print(indent int) string {
    str := ""

    for i := 0; i < indent; i++ {
        str += "  "
    }
    str += fmt.Sprintf("%s %s:\n", a.Type, a.PrintValue())
    for _, el := range(a.Subvalues){
        str += el.Print(indent+1)
    }
    return str
}

func toIfaceSlice(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}

func main(){
    input := `-4 + -50.0 * 2 + 66.7 + "hi {boo}" / 'n'`
    fmt.Println(input)
    r := strings.NewReader(input)
    result, err := ParseReader("", r)
    ast := result.(Ast)

    fmt.Println("=", ast.Print(0))
    fmt.Println(err)
}

}

Expr = op:BinOp rest:(BinOp)* _ EOF {
    vals := rest.([]interface{})
    if len(vals) > 0 {
        subvalues := []Ast{op.(Ast)}
        for _, el := range(vals){
            subvalues = append(subvalues, el.(Ast))
        }
        return Ast{Type: "Expr", Subvalues: subvalues, ValueType:CONTAINER }, nil
    } else {
        return Ast{Type: "Expr", Subvalues: []Ast{op.(Ast)}, ValueType:CONTAINER }, nil
    }
}

BinOp = _ first:Value __ op:Operator __ second:Expr {
    ast := Ast{Type:"BinOp", Subvalues:[]Ast{first.(Ast), op.(Ast), second.(Ast)},
        ValueType: CONTAINER}
    return ast, nil
}
/ _ first:Value __ op:Operator __ second:Value {
    ast := Ast{Type:"BinOp", Subvalues:[]Ast{first.(Ast), op.(Ast), second.(Ast)},
    ValueType: CONTAINER}
    return ast, nil
}

Operator = ( '*' / '/' / "/." / "*." ) {
    return Ast{Type:"Op", StringValue:string(c.text), ValueType:STRING}, nil
}
/ ( '+' / '-' / "+." / "-." ) {
    return Ast{Type:"Op", StringValue:string(c.text), ValueType:STRING}, nil
}

Value = v:Const {
    return v.(Ast), nil
}

Const = '-'? [0-9]+ !'.' {
    val, err := strconv.Atoi(string(c.text))
    if err != nil {
        return nil, err
    }
    return  Ast{Type:"Integer", IntValue:val, ValueType:INT}, nil
}
/ '-'? [0-9]+ '.' [0-9]+ {
    val, err := strconv.ParseFloat(string(c.text),64)
    if err != nil {
        return nil, err
    }
    return  Ast{Type:"Float", FloatValue:val, ValueType:FLOAT}, nil
}
/ "True" / "False" {
    if string(c.text) == "True" {
        return Ast{Type:"Bool", BoolValue: true, ValueType:BOOL}, nil
    }
    return Ast{Type:"Bool", BoolValue: false, ValueType:BOOL}, nil
}
/ '"' (!EscapedChar .)* '"' {
    val, err := strconv.Unquote(string(c.text))
    if err == nil {
        return Ast{Type:"String", StringValue: val, ValueType:STRING}, nil
    }
    return nil, err
}
/ "'" val:(!EscapedChar .) "'" {
    return Ast{Type:"String", StringValue: string(c.text), ValueType:STRING}, nil
}

EscapedChar = [\x00-\x1f"\\]

EscapeSequence = SingleCharEscape / UnicodeEscape

SingleCharEscape = ["\\/bfnrt]

DecimalDigit = [0-9]

NonZeroDecimalDigit = [1-9]

HexDigit = [0-9a-f]i

__ "sigwhitespace" = [ \r\n\t]+

_ "whitespace" = [ \r\n\t]*

EOF = !.