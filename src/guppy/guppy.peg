{
package main

type ValueType int

const (
    STRING = iota
    INT
    FLOAT
    BOOL
    CHAR
    CONTAINER
    NIL
)

type BasicAst struct {
    Type string
    StringValue string
    CharValue rune
    BoolValue bool
    IntValue int
    FloatValue float64
    ValueType ValueType
    Subvalues []Ast
}

type Func struct {
    Arguments []Ast
    ValueType ValueType
    Subvalues []Ast
}

type If struct {
    Condition Ast
    Then []Ast
    Else []Ast
}

type Ast interface {
    Print(indent int) string
}

func main(){
    input := `

let a = 5.0 + 6.5;
let adder = fun num {
    if num > 0 and num < 10 {
        20 + num;
    } else {
        5 + num;
    }
}
let cheesy = fun item {
    item ++ " with cheese";
}
let tester = fun a {
    let result = if a > 100 {
        a + 1;
    } else if a > 50 {
        a + 5;
    } else if a > 20 {
        a + 10;
    } else {
        a + 20;
    }
    result;
}
`
    fmt.Println(input)
    r := strings.NewReader(input)
    result, err := ParseReader("", r)
    ast := result.(Ast)
    fmt.Println("=", ast.Print(0))
    fmt.Println(err)
}

func (a BasicAst) String() string {
    switch (a.ValueType){
        case STRING:
            return fmt.Sprintf("\"%s\"", a.StringValue)
        case CHAR:
            return fmt.Sprintf("'%s'", string(a.CharValue))
        case INT:
            return fmt.Sprintf("%d", a.IntValue)
        case FLOAT:
            return fmt.Sprintf("%f", a.FloatValue)
    }
    return "()"
}

func (a BasicAst) Print(indent int) string {
    str := ""

    for i := 0; i < indent; i++ {
        str += "  "
    }
    str += fmt.Sprintf("%s %s:\n", a.Type, a)
    for _, el := range(a.Subvalues){
        str += el.Print(indent+1)
    }
    return str
}

func (a Func) String() string {
    return "Fun"
}

func (i If) String() string {
    return "If"
}

func (a Func) Print(indent int) string {
    str := ""

    for i := 0; i < indent; i++ {
        str += "  "
    }
    str += "Fun"
    if len(a.Arguments) > 0 {
        str += " (\n"
        for _, el := range(a.Arguments){
            str += el.Print(indent + 1)
        }
        for i := 0; i < indent; i++ {
            str += "  "
        }
        str += ")\n"
    }
    for _, el := range(a.Subvalues){
        str += el.Print(indent+1)
    }
    return str
}

func (i If) Print(indent int) string {
    str := ""

    for i := 0; i < indent; i++ {
        str += "  "
    }
    str += "If"
    if i.Condition != nil {
        str += ":\n"
        str += i.Condition.Print(indent + 1)

    }
    for _, el := range(i.Then){
        for i := 0; i < indent; i++ {
            str += "  "
        }
        str += "Then:\n"
        str += el.Print(indent+1)
    }
    for _, el := range(i.Else){
        for i := 0; i < indent; i++ {
            str += "  "
        }
        str += "Else:\n"
        str += el.Print(indent+1)

    }
    return str
}

func toIfaceSlice(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}

}

Module = _ expr:Statement _ rest:(Statement)* _ EOF {
    fmt.Println("beginning module")
    vals := rest.([]interface{})
    if len(vals) > 0 {
        fmt.Println("multiple statements")
        subvalues := []Ast{expr.(Ast)}
        for _, el := range(vals){
            subvalues = append(subvalues, el.(Ast))
        }
        return BasicAst{Type: "Module", Subvalues: subvalues, ValueType:CONTAINER }, nil
    } else {
        return BasicAst{Type: "Module", Subvalues: []Ast{expr.(Ast)}, ValueType:CONTAINER }, nil
    }
}

Statement = "let" __ i:Identifier _ '=' _ expr:Expr _ {
    fmt.Printf("assignment: %s\n", string(c.text))
    return BasicAst{Type: "Assignment", Subvalues: []Ast{i.(Ast), expr.(Ast)}, ValueType:CONTAINER }, nil
} / Expr

Expr = ex:(FuncDefn / IfExpr / BinExpr){
    fmt.Printf("expr: %s\n", string(c.text))
    return ex, nil
}

IfExpr = "if" __ expr:BinOpBool _ '{' _ thens:(Statement)+ _ '}' _ "else" _ elseifs:IfExpr {
    fmt.Printf("if: %s\n", string(c.text))
    subvalues := []Ast{}
    vals := thens.([]interface{})
    if len(vals) > 0 {
        for _, el := range(vals){
            subvalues = append(subvalues, el.(Ast))
        }
    }
    return If{Condition: expr.(Ast), Then: subvalues, Else: []Ast{elseifs.(Ast)} }, nil
}
/
"if" __ expr:BinOpBool _ '{' _ thens:(Statement)+ _ '}' _ "else" _ '{' _ elses:(Statement)+ _ '}' _ {
    fmt.Printf("if: %s\n", string(c.text))
    subvalues := []Ast{}
    vals := thens.([]interface{})
    if len(vals) > 0 {
        for _, el := range(vals){
            subvalues = append(subvalues, el.(Ast))
        }
    }
    elsevalues := []Ast{}
    vals = elses.([]interface{})
    if len(vals) > 0 {
        for _, el := range(vals){
            elsevalues = append(elsevalues, el.(Ast))
        }
    }
    return If{Condition: expr.(Ast), Then: subvalues, Else: elsevalues }, nil
}
/
"if" __ expr:BinOpBool _ '{' _ thens:(Statement)+ '}' _ {
    fmt.Printf("if: %s\n", string(c.text))
    subvalues := []Ast{}
    vals := thens.([]interface{})
    if len(vals) > 0 {
        for _, el := range(vals){
            subvalues = append(subvalues, el.(Ast))
        }
    }
    return If{Condition: expr.(Ast), Then: subvalues }, nil
}

FuncDefn = "fun" __ ids:(Identifier __)* _ "->"? _ '{' _ statements:(Statement)+ _ '}' _ {
    fmt.Println("func", string(c.text))
    subvalues := []Ast{}
    args := []Ast{}
    vals := statements.([]interface{})
    if len(vals) > 0 {
        for _, el := range(vals){
            subvalues = append(subvalues, el.(Ast))
        }
    }
    vals = ids.([]interface{})
    if len(vals) > 0 {
        restSl := toIfaceSlice(ids)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[0].(Ast)
            args = append(args, v)
        }
    }
    return Func{Arguments: args, Subvalues: subvalues, ValueType:CONTAINER }, nil
}

BinExpr = _ op:BinOp rest:(BinOp)* _ ';' _ {
    vals := rest.([]interface{})
    if len(vals) > 0 {
        subvalues := []Ast{op.(Ast)}
        for _, el := range(vals){
            subvalues = append(subvalues, el.(Ast))
        }
        return BasicAst{Type: "BinExpr", Subvalues: subvalues, ValueType:CONTAINER }, nil
    } else {
        return BasicAst{Type: "BinExpr", Subvalues: []Ast{op.(Ast)}, ValueType:CONTAINER }, nil
    }
}

BinOp = BinOpBool / BinOpEquality / BinOpLow / BinOpHigh

BinOpBool = _ first:BinOpEquality rest:(__ OperatorBoolean __ BinOpEquality)* {
    vals := rest.([]interface{})
    if len(vals) > 0 {
        subvalues := []Ast{first.(Ast)}
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[3].(Ast)
            op := restExpr[1].(Ast)
            subvalues = append(subvalues, op, v)
        }
        return BasicAst{Type: "BinOpBool", Subvalues: subvalues, ValueType:CONTAINER }, nil
    } else {
        return first.(Ast), nil
    }
}

BinOpEquality = _ first:BinOpLow rest:(__ OperatorEquality __ BinOpLow)* {
    vals := rest.([]interface{})
    if len(vals) > 0 {
        subvalues := []Ast{first.(Ast)}
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[3].(Ast)
            op := restExpr[1].(Ast)
            subvalues = append(subvalues, op, v)
        }
        return BasicAst{Type: "BinOpEquality", Subvalues: subvalues, ValueType:CONTAINER }, nil
    } else {
        return first.(Ast), nil
    }

}

BinOpLow = _ first:BinOpHigh rest:(__ OperatorLow __ BinOpHigh)* {
    vals := rest.([]interface{})
    if len(vals) > 0 {
        subvalues := []Ast{first.(Ast)}
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[3].(Ast)
            op := restExpr[1].(Ast)
            subvalues = append(subvalues, op, v)
        }
        return BasicAst{Type: "BinOpLow", Subvalues: subvalues, ValueType:CONTAINER }, nil
    } else {
        return first.(Ast), nil
    }

}

BinOpHigh = _ first:Value rest:(__ OperatorHigh __ Value)* {
    vals := rest.([]interface{})
    if len(vals) > 0 {
        subvalues := []Ast{first.(Ast)}
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[3].(Ast)
            op := restExpr[1].(Ast)
            subvalues = append(subvalues, op, v)
        }
        return BasicAst{Type: "BinOpHigh", Subvalues: subvalues, ValueType:CONTAINER }, nil
    } else {
        return first.(Ast), nil
    }
}

Operator = OperatorBoolean / OperatorEquality / OperatorHigh / OperatorLow

OperatorBoolean = ( "not" / "or" / "and" ) {
    return BasicAst{Type:"BoolOp", StringValue:string(c.text), ValueType:STRING}, nil
}

OperatorEquality = ( ">=" / "<=" / '<' / '>' / "===" / "=="){
    return BasicAst{Type:"EqualityOperator", StringValue:string(c.text), ValueType:STRING}, nil
}

OperatorHigh = ( "/." / "*." ) {
    return BasicAst{Type:"FloatOperator", StringValue:string(c.text), ValueType:STRING}, nil
}
/ ( '*' / '/' / '^' ) {
    return BasicAst{Type:"IntOperator", StringValue:string(c.text), ValueType:STRING}, nil
}
/ "++" {
    return BasicAst{Type:"StringOperator", StringValue:string(c.text), ValueType:STRING}, nil
}

OperatorLow = ( "+." / "-." ) {
    return BasicAst{Type:"FloatOperator", StringValue:string(c.text), ValueType:STRING}, nil
}
/ ( '+' / '-' ) {
    return BasicAst{Type:"IntOperator", StringValue:string(c.text), ValueType:STRING}, nil
}

Value = '(' expr:Expr ')' {
    return expr.(Ast), nil
}
/ Identifier / v:Const {
    return v.(Ast), nil
}

Identifier = ([a-z]+ [a-zA-Z0-9_]* / '_') {
    return  BasicAst{Type:"Identifier", StringValue:string(c.text), ValueType:STRING}, nil
}

Const = '-'? [0-9]+ !'.' {
    val, err := strconv.Atoi(string(c.text))
    if err != nil {
        return nil, err
    }
    return  BasicAst{Type:"Integer", IntValue:val, ValueType:INT}, nil
}
/ '-'? [0-9]+ '.' [0-9]+ {
    val, err := strconv.ParseFloat(string(c.text),64)
    if err != nil {
        return nil, err
    }
    return  BasicAst{Type:"Float", FloatValue:val, ValueType:FLOAT}, nil
}
/ "True" / "False" {
    if string(c.text) == "True" {
        return BasicAst{Type:"Bool", BoolValue: true, ValueType:BOOL}, nil
    }
    return BasicAst{Type:"Bool", BoolValue: false, ValueType:BOOL}, nil
}
/ "()" {
    return BasicAst{Type:"Nil", ValueType:NIL}, nil
}
/ '"' (!EscapedChar .)* '"' {
    val, err := strconv.Unquote(string(c.text))
    if err == nil {
        return BasicAst{Type:"String", StringValue: val, ValueType:STRING}, nil
    }
    return nil, err
}
/ "'" val:(!EscapedChar .) "'" {
    return BasicAst{Type:"Char", CharValue: rune(c.text[1]), ValueType:CHAR}, nil
}

EscapedChar = [\x00-\x1f"\\]

EscapeSequence = SingleCharEscape / UnicodeEscape

SingleCharEscape = ["\\/bfnrt]

DecimalDigit = [0-9]

NonZeroDecimalDigit = [1-9]

HexDigit = [0-9a-f]i

__ "sigwhitespace" = [ \r\n\t]+

_ "whitespace" = [ \r\n\t]*

EOF = !.