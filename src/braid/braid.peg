{
package main

type ValueType int

const (
    STRING = iota
    INT
    FLOAT
    BOOL
    CHAR
    CONTAINER
    NIL
)

type BasicAst struct {
    Type string
    StringValue string
    CharValue rune
    BoolValue bool
    IntValue int
    FloatValue float64
    ValueType ValueType
    Subvalues []Ast
}

type Func struct {
    Arguments []Ast
    ValueType ValueType
    Subvalues []Ast
}

type Call struct {
    Module Ast
    Function Ast
    Arguments []Ast
    ValueType ValueType
}

type If struct {
    Condition Ast
    Then []Ast
    Else []Ast
}

type Assignment struct {
    Left []Ast
    Right Ast
}

type Ast interface {
    Print(indent int) string
}

func (a BasicAst) String() string {
    switch (a.ValueType){
        case STRING:
            return fmt.Sprintf("\"%s\"", a.StringValue)
        case CHAR:
            return fmt.Sprintf("'%s'", string(a.CharValue))
        case INT:
            return fmt.Sprintf("%d", a.IntValue)
        case FLOAT:
            return fmt.Sprintf("%f", a.FloatValue)
    }
    return "()"
}

func (a BasicAst) Print(indent int) string {
    str := ""

    for i := 0; i < indent; i++ {
        str += "  "
    }
    str += fmt.Sprintf("%s %s:\n", a.Type, a)
    for _, el := range(a.Subvalues){
        str += el.Print(indent+1)
    }
    return str
}

func (a Func) String() string {
    return "Func"
}

func (i If) String() string {
    return "If"
}

func (a Func) Print(indent int) string {
    str := ""

    for i := 0; i < indent; i++ {
        str += "  "
    }
    str += "Func"
    if len(a.Arguments) > 0 {
        str += " (\n"
        for _, el := range(a.Arguments){
            str += el.Print(indent + 1)
        }
        for i := 0; i < indent; i++ {
            str += "  "
        }
        str += ")\n"
    }
    for _, el := range(a.Subvalues){
        str += el.Print(indent+1)
    }
    return str
}

func (a Call) Print(indent int) string {
    str := ""

    for i := 0; i < indent; i++ {
        str += "  "
    }
    str += "Call:\n"
    if a.Module.(BasicAst).Type != "" {
        str += a.Module.Print(indent + 1)
    }
    str += a.Function.Print(indent + 1)

    if len(a.Arguments) > 0 {
        for i := 0; i < indent; i++ {
            str += "  "
        }
        str += "(\n"
        for _, el := range(a.Arguments){
            str += el.Print(indent + 1)
        }
        for i := 0; i < indent; i++ {
            str += "  "
        }
        str += ")\n"
    }
    return str
}

func (i If) Print(indent int) string {
    str := ""

    for i := 0; i < indent; i++ {
        str += "  "
    }
    str += "If"
    if i.Condition != nil {
        str += ":\n"
        str += i.Condition.Print(indent + 1)

    }
    for _, el := range(i.Then){
        for i := 0; i < indent; i++ {
            str += "  "
        }
        str += "Then:\n"
        str += el.Print(indent+1)
    }
    for _, el := range(i.Else){
        for i := 0; i < indent; i++ {
            str += "  "
        }
        str += "Else:\n"
        str += el.Print(indent+1)

    }
    return str
}

func (a Assignment) Print(indent int) string {
    str := ""

    for i := 0; i < indent; i++ {
        str += "  "
    }
    str += "Assignment:\n"

    for _, el := range(a.Left){
        str += el.Print(indent+1)
    }
    str += a.Right.Print(indent+1)

    return str
}

func toIfaceSlice(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}

}

Module = _ stat:TopLevelStatement _ rest:(TopLevelStatement)* _ EOF {
    //fmt.Println("beginning module")
    vals := rest.([]interface{})
    if len(vals) > 0 {
        //fmt.Println("multiple statements")
        subvalues := []Ast{stat.(Ast)}
        for _, el := range(vals){
            subvalues = append(subvalues, el.(Ast))
        }
        return Module{Name:"", Subvalues: subvalues}, nil
    } else {
        return Module{Name:"", Subvalues: []Ast{stat.(Ast)} }, nil
    }
}

TopLevelStatement = Comment / FuncDefn / TypeDefn

Statement = Comment / FuncDefn / Assignment / Call / ExprLine

ExprLine = e:Expr &'\n' {
    return e, nil
}

Comment = '#' comment:(!EscapedChar .)* &'\n' {
    //fmt.Println("comment:", string(c.text))
    return BasicAst{Type: "Comment", StringValue: string(c.text[1:]), ValueType:STRING }, nil
}

TypeDefn = _ "type" __ name:ModuleName params:(__ TypeParameter)* _ '=' types:(__ AnyType)+ __ {
    // alias type
    parameters := []Ast{}
    fields := []Ast{}

    vals := types.([]interface{})
    if len(vals) > 0 {
        restSl := toIfaceSlice(types)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[1].(Ast)
            fields = append(fields, v)
        }
    }

    return AliasType{Name: name.(BasicAst).StringValue, Params: parameters, Types: fields }, nil
}
/
_ "type" __ name:ModuleName params:(__ TypeParameter)* _ '=' _
    '{' _ first:RecordFieldDefn _ rest:(',' _ RecordFieldDefn _)* ','? _ '}' __ {
    // record type
    fields := []RecordField{first.(RecordField)}

    vals := rest.([]interface{})
    if len(vals) > 0 {
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[2].(RecordField)
            fields = append(fields, v)
        }
    }

    return RecordType{Name: name.(BasicAst).StringValue, Fields: fields}, nil
}
/
_ "type" __ name:ModuleName params:(__ TypeParameter)* _ '=' _ rest:(VariantConstructor)+ {
    // variant type
    parameters := []Ast{}
    constructors := []VariantConstructor{}

    vals := rest.([]interface{})
    if len(vals) > 0 {
        for _, v := range vals {
            constructors = append(constructors, v.(VariantConstructor))
        }
    }

    return VariantType{Name: name.(BasicAst).StringValue, Params: parameters, Constructors: constructors}, nil
}

RecordFieldDefn = name:VariableName _ ':' _ t:(AnyType) {
    return RecordField{Name: name.(BasicAst).StringValue, Type: t.(Ast)}, nil
}

VariantConstructor = '|' _ name:ModuleName _ '{' _ first:RecordFieldDefn _ rest:(',' _ RecordFieldDefn _)* ','? _ '}' __ {
    // variant constructor with a record type
    fields := []RecordField{first.(RecordField)}

    vals := rest.([]interface{})
    if len(vals) > 0 {
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[2].(RecordField)
            fields = append(fields, v)
        }
    }

    record := RecordType{Name: name.(BasicAst).StringValue, Fields: fields}
    return VariantConstructor{Name: name.(BasicAst).StringValue, Fields: []Ast{record}}, nil
}
/
'|' _ name:ModuleName rest:(__ AnyType)* _ {
    params := []Ast{}

    vals := rest.([]interface{})
    if len(vals) > 0 {
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[1].(Ast)
            params = append(params, v)
        }
    }

    return VariantConstructor{Name: name.(BasicAst).StringValue, Fields: params}, nil
}



AnyType = BaseType / TypeParameter

Assignment = _ "let" __ i:Assignable rest:(',' _ Assignable)* _ '=' _ expr:Expr _ {
    //fmt.Println("assignment:", string(c.text))
    vals := []Ast{i.(Ast)}
    if len(rest.([]interface{})) > 0 {
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[2].(Ast)
            vals = append(vals, v)
        }
    }
    return Assignment{Left: vals, Right: expr.(Ast)}, nil
}
/
_ "let" __ !Assignable {
    return nil, errors.New("Variable name or '_' (unused result character) required here")
}
/
_ "let" __ i:Assignable rest:(',' _ Assignable)* _ !'=' {
    return nil, errors.New("When assigning a value to a variable, you must use '='")
}

FuncDefn = _ "let" __ i:VariableName _ '=' _ "func" __ ids:(VariableName __)* _ '{' __ statements:(Statement)+ _ '}' _ {
    //fmt.Println(string(c.text))
    subvalues := []Ast{}
    args := []Ast{}
    vals := statements.([]interface{})
    if len(vals) > 0 {
        for _, el := range(vals){
            subvalues = append(subvalues, el.(Ast))
        }
    }
    vals = ids.([]interface{})
    if len(vals) > 0 {
        restSl := toIfaceSlice(ids)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[0].(Ast)
            args = append(args, v)
        }
    }
    return Func{Name: i.(BasicAst).StringValue, Arguments: args, Subvalues: subvalues }, nil
}

Expr = ex:(IfExpr / Call / CompoundExpr) {
    //fmt.Printf("top-level expr: %s\n", string(c.text))
    //fmt.Println(ex)
    return ex, nil
}

IfExpr = "if" __ expr:BinOpBool _ '{' _ thens:(Statement)+ _ '}' _ "else" _ elseifs:IfExpr {
    //fmt.Printf("if: %s\n", string(c.text))
    subvalues := []Ast{}
    vals := thens.([]interface{})
    if len(vals) > 0 {
        for _, el := range(vals){
            subvalues = append(subvalues, el.(Ast))
        }
    }
    return If{Condition: expr.(Ast), Then: subvalues, Else: []Ast{elseifs.(Ast)} }, nil
}
/
"if" __ expr:BinOpBool _ '{' _ thens:(Statement)+ __ '}' _ "else" _ '{' _ elses:(Statement)+ __ '}' {
    //fmt.Printf("if: %s\n", string(c.text))
    subvalues := []Ast{}
    vals := thens.([]interface{})
    if len(vals) > 0 {
        for _, el := range(vals){
            subvalues = append(subvalues, el.(Ast))
        }
    }
    elsevalues := []Ast{}
    vals = elses.([]interface{})
    if len(vals) > 0 {
        for _, el := range(vals){
            elsevalues = append(elsevalues, el.(Ast))
        }
    }
    return If{Condition: expr.(Ast), Then: subvalues, Else: elsevalues }, nil
}
/
"if" __ expr:BinOpBool _ '{' _ thens:(Statement)+ __ '}' {
    //fmt.Printf("if: %s\n", string(c.text))
    subvalues := []Ast{}
    vals := thens.([]interface{})
    if len(vals) > 0 {
        for _, el := range(vals){
            subvalues = append(subvalues, el.(Ast))
        }
    }
    return If{Condition: expr.(Ast), Then: subvalues }, nil
}

Call = module:ModuleName '.' fn:VariableName args:Arguments _ {
    //fmt.Println("call", string(c.text))
    arguments := []Ast{}

    if args.(BasicAst).ValueType != NIL {
        arguments = args.(BasicAst).Subvalues

    }

    return Call{Module: module.(Ast), Function: fn.(Ast), Arguments: arguments }, nil
}
/
fn:VariableName args:Arguments _ {
    //fmt.Println("call", string(c.text))
    arguments := []Ast{}

    if args.(BasicAst).ValueType != NIL {
        arguments = args.(BasicAst).Subvalues

    }

    return Call{Module: nil, Function: fn.(Ast), Arguments: arguments }, nil
}

Arguments = '(' _ argument:BinOpParens _ rest:(',' _ BinOpParens)* _ ')' {
    args := []Ast{argument.(Ast)}

    vals := rest.([]interface{})
    if len(vals) > 0 {
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[2].(Ast)
            args = append(args, v)
        }
    }

    return BasicAst{Type: "Arguments", Subvalues: args, ValueType:CONTAINER }, nil
}
/
'(' _ argument:Expr _ ')' {
    args := []Ast{argument.(Ast)}
    return BasicAst{Type: "Arguments", Subvalues: args, ValueType:CONTAINER }, nil
}
/
Unit


CompoundExpr = _ op:BinOp rest:(__ Operator __ BinOp)* {
    //fmt.Println("compound", op, rest)
    vals := rest.([]interface{})
    if len(vals) > 0 {
        subvalues := []Ast{op.(Ast)}
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[3].(Ast)
            op := restExpr[1].(Ast)
            subvalues = append(subvalues, op, v)
        }

        return BasicAst{Type: "CompoundExpr", Subvalues: subvalues, ValueType:CONTAINER }, nil
    } else {
        return BasicAst{Type: "CompoundExpr", Subvalues: []Ast{op.(Ast)}, ValueType:CONTAINER }, nil
    }
}

BinOp = BinOpBool / BinOpEquality / BinOpLow / BinOpHigh / BinOpParens

BinOpBool = _ first:BinOpEquality rest:(__ OperatorBoolean __ BinOpEquality)* {
    //fmt.Println("binopbool", first, rest)
    vals := rest.([]interface{})
    if len(vals) > 0 {
        subvalues := []Ast{first.(Ast)}
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[3].(Ast)
            op := restExpr[1].(Ast)
            subvalues = append(subvalues, op, v)
        }
        return BasicAst{Type: "BinOpBool", Subvalues: subvalues, ValueType:CONTAINER }, nil
    } else {
        return first.(Ast), nil
    }
}

BinOpEquality = _ first:BinOpLow rest:(__ OperatorEquality __ BinOpLow)* {
    //fmt.Println("binopeq", first, rest)
    vals := rest.([]interface{})
    if len(vals) > 0 {
        subvalues := []Ast{first.(Ast)}
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[3].(Ast)
            op := restExpr[1].(Ast)
            subvalues = append(subvalues, op, v)
        }
        return BasicAst{Type: "BinOpEquality", Subvalues: subvalues, ValueType:CONTAINER }, nil
    } else {
        return first.(Ast), nil
    }

}

BinOpLow = _ first:BinOpHigh rest:(__ OperatorLow __ BinOpHigh)* {
    //fmt.Println("binoplow", first, rest)
    vals := rest.([]interface{})
    if len(vals) > 0 {
        subvalues := []Ast{first.(Ast)}
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[3].(Ast)
            op := restExpr[1].(Ast)
            subvalues = append(subvalues, op, v)
        }
        return BasicAst{Type: "BinOpLow", Subvalues: subvalues, ValueType:CONTAINER }, nil
    } else {
        return first.(Ast), nil
    }

}

BinOpHigh = _ first:BinOpParens rest:(__ OperatorHigh __ BinOpParens)* {
    //fmt.Println("binophigh", first, rest)
    vals := rest.([]interface{})
    if len(vals) > 0 {
        subvalues := []Ast{first.(Ast)}
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[3].(Ast)
            op := restExpr[1].(Ast)
            subvalues = append(subvalues, op, v)
        }
        return BasicAst{Type: "BinOpHigh", Subvalues: subvalues, ValueType:CONTAINER }, nil
    } else {
        return first.(Ast), nil
    }
}

BinOpParens = '(' _ first:BinOp _ ')' {
    //fmt.Println("binopparens", first)
    return BasicAst{Type: "BinOpParens", Subvalues: []Ast{first.(Ast)}, ValueType:CONTAINER }, nil
} / Value

Operator = OperatorBoolean / OperatorEquality / OperatorHigh / OperatorLow

OperatorBoolean = ( "not" / "or" / "and" ) {
    return BasicAst{Type:"BoolOp", StringValue:string(c.text), ValueType:STRING}, nil
}

OperatorEquality = ( ">=" / "<=" / '<' / '>' / "===" / "=="){
    return BasicAst{Type:"EqualityOperator", StringValue:string(c.text), ValueType:STRING}, nil
}

OperatorHigh = ( "/." / "*." ) {
    return BasicAst{Type:"FloatOperator", StringValue:string(c.text), ValueType:STRING}, nil
}
/ ( '*' / '/' / '^' ) {
    return BasicAst{Type:"IntOperator", StringValue:string(c.text), ValueType:STRING}, nil
}
/ "++" {
    return BasicAst{Type:"StringOperator", StringValue:string(c.text), ValueType:STRING}, nil
}

OperatorLow = ( "+." / "-." ) {
    return BasicAst{Type:"FloatOperator", StringValue:string(c.text), ValueType:STRING}, nil
}
/ ( '+' / '-' ) {
    return BasicAst{Type:"IntOperator", StringValue:string(c.text), ValueType:STRING}, nil
}

Value = VariableName / Const

Assignable = VariableName / Unused

Identifier = VariableName / ModuleName

ArrayLiteral = '[' _ first:Expr _ rest:(',' _ Expr _)* ','? _ ']' {
    // rest:(_ ',' _ Expr)*
    vals := rest.([]interface{})
    subvalues := []Ast{first.(Ast)}
    if len(vals) > 0 {
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            v := restExpr[2].(Ast)
            subvalues = append(subvalues, v)
        }
    }
    return BasicAst{Type: "Array", Subvalues: subvalues, ValueType:CONTAINER }, nil
}

VariantInstance = name:ModuleName _ args:Arguments {
    arguments := []Ast{}

    if args.(BasicAst).ValueType != NIL {
        arguments = args.(BasicAst).Subvalues

    }
    return VariantInstance{Name:name.(BasicAst).StringValue, Arguments: arguments }, nil
}

RecordInstance = name:ModuleName _ '{' _ firstName:VariableName _ ':' _ firstValue:Expr rest:(',' _ VariableName _ ':' _ Expr )* '}' {
    instance := RecordInstance{Name: name.(BasicAst).StringValue}
    instance.Values = make(map[string]Ast)

    vals := rest.([]interface{})
    instance.Values[firstName.(BasicAst).StringValue] = firstValue.(Ast)

    if len(vals) > 0 {
        restSl := toIfaceSlice(rest)
        for _, v := range restSl {
            // we can get each item in the grammar by index
            restExpr := toIfaceSlice(v)
            k := restExpr[2].(BasicAst).StringValue
            v := restExpr[6].(Ast)
            instance.Values[k] = v
        }
    }
    return instance, nil
}

TypeParameter = '\'' VariableName {
    return  BasicAst{Type:"TypeParam", StringValue:string(c.text), ValueType:STRING}, nil
}

VariableName = !Reserved ([a-z]+ [a-zA-Z0-9_]*) {
    return  BasicAst{Type:"Identifier", StringValue:string(c.text), ValueType:STRING}, nil
}

ModuleName = ([A-Z]+ [a-zA-Z0-9_]*) {
    return  BasicAst{Type:"Identifier", StringValue:string(c.text), ValueType:STRING}, nil
}

Const = '-'? [0-9]+ !'.' {
    val, err := strconv.Atoi(string(c.text))
    if err != nil {
        return nil, err
    }
    return  BasicAst{Type:"Integer", IntValue:val, ValueType:INT}, nil
}
/ '-'? [0-9]+ '.' [0-9]+ {
    val, err := strconv.ParseFloat(string(c.text),64)
    if err != nil {
        return nil, err
    }
    return  BasicAst{Type:"Float", FloatValue:val, ValueType:FLOAT}, nil
}
/ "true" / "false" {
    if string(c.text) == "true" {
        return BasicAst{Type:"Bool", BoolValue: true, ValueType:BOOL}, nil
    }
    return BasicAst{Type:"Bool", BoolValue: false, ValueType:BOOL}, nil
}
/ Unit
/ '"' (!EscapedChar .)* '"' {
    val, err := strconv.Unquote(string(c.text))
    if err == nil {
        return BasicAst{Type:"String", StringValue: val, ValueType:STRING}, nil
    }
    return nil, err
}
/ "'" val:(!EscapedChar .) "'" {
    return BasicAst{Type:"Char", CharValue: rune(c.text[1]), ValueType:CHAR}, nil
} / ArrayLiteral / RecordInstance / VariantInstance

Unit = "()" {
    return BasicAst{Type:"Nil", ValueType:NIL}, nil
}

Unused = ('_') {
    return  BasicAst{Type:"Identifier", StringValue:string(c.text), ValueType:STRING}, nil
}

Reserved = ("let" / "if" / "else" / "func" / "type" / "true" / "false" / "mutable" / "type" / BaseType) ![a-z]+

BaseType = ( "int" / "bool" / "string" / "byte" / "rune" / "float" / "list" ) {
    return  BasicAst{Type:"Type", StringValue:string(c.text), ValueType:STRING}, nil
}

EscapedChar = [\x00-\x1f"\\]

EscapeSequence = SingleCharEscape / UnicodeEscape

SingleCharEscape = ["\\/bfnrt]

DecimalDigit = [0-9]

NonZeroDecimalDigit = [1-9]

HexDigit = [0-9a-f]i

__ "sigwhitespace" = [ \r\n\t]+

_ "whitespace" = [ \r\n\t]*

EOF = !.
